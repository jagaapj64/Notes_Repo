https://www.youtube.com/watch?v=CCTgroOcyfM&list=PL_mJOmq4zsHZYAyK606y7wjQtC0aoE6Es&index=1
https://www.youtube.com/watch?v=iGKOdep1Iss&list=PL_mJOmq4zsHZYAyK606y7wjQtC0aoE6Es&index=2
https://www.youtube.com/watch?v=iGKOdep1Iss&list=PL_mJOmq4zsHZYAyK606y7wjQtC0aoE6Es&index=3
https://www.youtube.com/watch?v=iGKOdep1Iss&list=PL_mJOmq4zsHZYAyK606y7wjQtC0aoE6Es&index=4
https://www.youtube.com/watch?v=iGKOdep1Iss&list=PL_mJOmq4zsHZYAyK606y7wjQtC0aoE6Es&index=5
https://www.youtube.com/watch?v=iGKOdep1Iss&list=PL_mJOmq4zsHZYAyK606y7wjQtC0aoE6Es&index=6

											   Part 1: Intro to Elasticsearch & Kibana
											   ```````````````````````````````````````

											   
Getting information about cluster and nodes
```````````````````````````````````````````
Syntax:-
``````
GET _API/parameter

Get info about cluster health:-
``````````````````````````````
GET _cluster/health

Get info about nodes in a cluster:-
`````````````````````````````````
GET _nodes/stats

Performing CRUD operations:-
``````````````````````````
Create an index:
Syntax:-

PUT Name-of-the-Index

Example:-
```````
PUT favorite_candy

Index a document:-
````````````````
When indexing a document, both HTTP verbs POST or PUT can be used.

1.Use POST when you want Elasticsearch to autogenerate an id for your document.

Syntax:-
```````

POST Name-of-the-Index/_doc
{
  "field": "value"
}

Example:-

POST favorite_candy/_doc
{
  "first_name": "Lisa",
  "candy": "Sour Skittles"
}

   Use PUT when you want to assign a specific id to your document(i.e. if your document has a natural identifier 
purchase order number, patient id, & etc). For more detailed explanation, check out this documentation
from Elastic!
Syntax:

PUT Name-of-the-Index/_doc/id-you-want-to-assign-to-this-document
{
  "field": "value"
}
Example:

PUT favorite_candy/_doc/1
{
  "first_name": "John",
  "candy": "Starburst"
}

1.create Endpoint:-
````````````````
  When you index a document using an id that already exists, the existing document is overwritten by the new document. 
If you do not want a existing document to be overwritten, you can use the _create endpoint!

  With the _create Endpoint, no indexing will occur and you will get a 409 error message.

Syntax:-
``````
  PUT Name-of-the-Index/_create/id-you-want-to-assign-to-this-document
  {
  "field": "value"
  }

Example:-
```````
PUT favorite_candy/_create/1
{
  "first_name": "Finn",
  "candy": "Jolly Ranchers"
}


{
  "error": {
    "root_cause": [
      {
        "type": "version_conflict_engine_exception",
        "reason": "[1]: version conflict, document already exists (current version [2])",
        "index_uuid": "-jXMjtDOQ6OJBVV1ZLUxdw",
        "shard": "0",
        "index": "favorite_candy"
      }
    ],
    "type": "version_conflict_engine_exception",
    "reason": "[1]: version conflict, document already exists (current version [2])",
    "index_uuid": "-jXMjtDOQ6OJBVV1ZLUxdw",
    "shard": "0",
    "index": "favorite_candy"
  },
  "status": 409
}


2.Read a document:-
````````````````
Syntax:-
``````
   GET Name-of-the-Index/_doc/id-of-the-document-you-want-to-retrieve

Example:-
```````
GET favorite_candy/_doc/1




3.Update a document:-
`````````````````

  If you want to update fields in a document, use the following

syntax:-
``````

   POST Name-of-the-Index/_update/id-of-the-document-you-want-to-update
{
  "doc": {
    "field1": "value",
    "field2": "value",
  }
} 

Example:-
```````

POST favorite_candy/_update/1
{
  "doc": {
    "candy": "M&M's"
  }
}

4.Delete a document:-
```````````````````
Syntax:-
``````
   DELETE Name-of-the-Index/_doc/id-of-the-document-you-want-to-delete

Example:-
```````

  DELETE favorite_candy/_doc/1
  
  
  
                                  Part 2: Understanding the relevance of your search with Elasticsearch and Kibana
								  ````````````````````````````````````````````````````````````````````````````````
								  
Search for information:-
```````````````````````
There are two main ways to search in Elasticsearch:

 1.Queries
 2.Aggregations

Queries:-
````````
Queries retrieve documents that match the criteria.

 1.Retrieve information about documents in an index

Syntax:-
``````
   GET enter_name_of_the_index_here/_search

Example:-
```````
   GET news_head_line2/_search

 2.Get the exact total number of hits
 
    To improve the response speed on large datasets, Elasticsearch limits the total count to 10,000 by default. If you want 
  the exact total number of hits, use the following query.

Syntax:-
``````
GET enter_name_of_the_index_here/_search
 
{
  "track_total_hits": true
}

Example:-
```````

GET news_head_line2/_search
{
  "track_total_hits": true
}

Expected response from Elasticsearch:-
You will see that the total number of hits is now 200,853.

 3.Search for data within a specific time range
 
Syntax:-
``````

GET enter_name_of_the_index_here/_search
{
  "query": {
    "Specify the type of query here": {
      "Enter name of the field here": {
        "gte": "Enter lowest value of the range here",
        "lte": "Enter highest value of the range here"
      }
    }
  }
}

Example:-
```````

GET news_head_line2/_search
{
  "query": {
   "range": {
     "date": {
       "gte": "2022-09-20",
       "lte": "2022-09-21"
     }
   } 
  }
}

Expected response from Elasticsearch:-
`````````````````````````````````````
  It will pull up articles published from June 20, 2015 through September 22, 2015. A document from the
result set was shown as an example.

 2.Aggregations:-
 ``````````````
  An aggregation summarizes your data as metrics, statistics, and other analytics.

 1.Analyze the data to show the categories of news headlines in our dataset
 
Syntax:-
``````

GET enter_name_of_the_index_here/_search
{
  "aggs": {
    "name your aggregation here": {
      "specify aggregation type here": {
        "field": "name the field you want to aggregate here",
        "size": state how many buckets you want returned here
      }
    }
  }
}

Example:-
```````
GET news_head_line2/_search
{
  "aggs": {
    "by_category": {
      "terms": {
        "field": "category",
        "size": 2
      }
    }
  }
}

 2.A combination of query and aggregation request
Search for the most significant term in a category

Syntax:-
``````

GET enter_name_of_the_index_here/_search
{
  "query": {
    "match": {
      "Enter the name of the field": "Enter the value you are looking for"
    }
  },
  "aggregations": {
    "Name your aggregation here": {
      "significant_text": {
        "field": "Enter the name of the field you are searching for"
      }
    }
  }
}

Example:-
```````
GET news_head_line2/_search
{
  "query": {
    "match": {
      "category": "ENTERTAINMENT"
    }
  },
  "aggregations":{
        "popular_in_entertainment":{
          "significant_text": {
            "field": "headline"
          }
        }    
  }
}

Precision and Recall:-
````````````````````
 1.Increasing Recall:-
 ```````````````````
 
Syntax:-
```````
GET enter_name_of_index_here/_search
{
  "query": {
    "match": {
      "Specify the field you want to search": {
        "query": "Enter search terms"
      }
    }
  }
}

Example:-
```````
GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Khloe Kardashian Kendall Jenner"
      }
    }
  }
}

Expected response from Elasticsearch:-
`````````````````````````````````````

 By default, the match query uses an "OR" logic. If a document contains one of the search terms, Elasticsearch 
will consider that document as a hit.

 "OR" logic results in higher number of hits, thereby increasing recall. However, the hits are loosely related 
to the query and lowering precision as a result.

 2.Increasing Precision:-
 ``````````````````````
  We can increase precision by adding an "and" operator to the query.

Syntax:-
```````
GET enter_name_of_index_here/_search
{
  "query": {
    "match": {
      "Specify the field you want to search": {
        "query": "Enter search terms",
        "operator": "and"
      }
    }
  }
}

Example:-
```````
GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Kardashian Kim",
        "operator": "and"
      }
    }
  }
}

Expected response from Elasticsearch:-
````````````````````````````````````

 "AND" operator will result in getting more precise matches, thereby increasing precision. However, it will reduce 
the number of hits returned, resulting in lower recall.

minimum_should_match
This parameter allows you to specify the minimum number of terms a document should have to be included in the search results.

This parameter gives you more control over fine tuning precision and recall of your search.

Syntax:-
``````

GET enter_name_of_index_here/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Enter search term here",
        "minimum_should_match": Enter a number here
      }
    }
  }
}

Example:-
```````

GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Kardashian Kim",
        "minimum_should_match": 2
      }
    }
  }
}

Expected response from Elasticsearch:-
````````````````````````````````````
  With minimum_should_match parameter, we were able to finetune both precision and recall!
  
  
                         Part 3: Running full text queries and combined queries with Elasticsearch and Kibana
						 ````````````````````````````````````````````````````````````````````````````````````	


Review from Workshop Part 2:-
```````````````````````````
There are two main ways to search in Elasticsearch:-
``````````````````````````````````````````````````

 1.Queries retrieve documents that match the specified criteria.
 2.Aggregations present the summary of your data as metrics, statistics, and other analytics.
 
Search queries:-
```````````````
  Get information about documents in an index:-
  
 The following query will retrieve all documents that exist in the specified index. This query is a great way to 
explore the structure and content of your document.

Syntax:-
``````

GET Enter_name_of_the_index_here/_search

Example:-
```````

GET news_head_line2/_search

Expected response from Elasticsearch:-

 Elasticsearch displays a number of hits and a sample of 10 search results by default. The field "_ source"(line 22) 
lists all fields(the content) of a document.

Aggregations Request;_
````````````````````
 Analyze the data to show the categories of news headlines in our dataset

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "aggregations": {
    "Name your aggregation here": {
      "Specify aggregation type here": {
        "field": "Name the field you want to aggregate here",
        "size": State how many buckets you want returned here
      }
    }
  }
}
Example:

GET news_head_line2/_search
{
  "aggregations": {
    "by_category": {
      "terms": {
        "field": "category",
        "size": 100
      }
    }
  }
}
Expected response from Elasticsearch:-
 When you minimize hits(line 10), you will see the aggregations report we named by_category. This report displays all 
categories that exist in our datset as well as the number of documents that fall under each category.


Full Text Queries:-
``````````````````

 1.Searching for search terms:-
 ``````````````````````````````
  The match query is a standard query for performing a full text search. This query retrieves documents that contain 
the search terms. It uses "OR" logic by default, meaning that it will retrieve documents that contain any one of the 
search terms. The order and the proximity in which the search terms are found(i.e. phrases) are not taken into account.

Syntax:-
```````

GET Enter_name_of_index_here/_search
{
  "query": {
    "match": {
      "Specify the field you want to search": {
        "query": "Enter search terms"
      }
    }
  }
}

Searching for a phrase:-
``````````````````````
 What happens when you use the match query to search for phrases?
 Let's search for articles about Ed Sheeran's song "Shape of you" using the match query.

Example:-
```````

GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Shape of you"
      }
    }
  }
}

  Along with a few articles about the song "Shape of you", it pulls up articles about being in shape or what shape of your 
face says about you.
  When the match query is used to search for a phrase, it has high recall but low precision. It pulls up more loosely related 
documents as it uses "OR" logic by default. It pulls up documents that contains any one of the search terms in the specified 
field. Moreover, the order and the proximity in which the search terms are found are not taken into account.

Searching for phrases using the match_phrase query:-
``````````````````````````````````````````````````
  If the order and the proximity in which the search terms are found(i.e. phrases) are important in determining the relevance 
of your search, you use the match_phrase query.

Example:-
```````
GET news_head_line2/_search
{
  "query": {
    "match_phrase": {
      "headline": {
        "query": "You Need"
      }
    }
  }
}

When the match_phrase parameter is used, all hits must meet the following criteria:-
```````````````````````````````````````````````````````````````````````````````````
  the search terms "Shape", "of", and "you" must appear in the field headline.
  the terms must appear in that order.
  the terms must appear next to each other.
  
Expected response from Elasticsearch:-
````````````````````````````````````
   With match_phrase parameter, we get 3 hits returned. All 3 hits satisfy the criteria mentioned above.
  The match_phrase parameter yields higher precision but lower recall as it takes the order and the proximity in which the search terms are found into account.
  
 Running a match query against multiple fields:-
 `````````````````````````````````````````````
  When designing a query, you don't always know the context of a user's search. When a user searches for "Michelle Obama", the
user could be searching for statements written by Michelle Obama or articles written about her.

  To accommodate these contexts, you can write a multi_match query, which searches for terms in multiple fields.
 
  The multi_match query runs a match query on multiple fields and calculates a score for each field. Then, it assigns the highest 
score among the fields to the document.

  This score will determine the ranking of the document within the search results.

syntax:-
``````
GET Enter_the_name_of_the_index_here/_search
{
  "query": {
    "multi_match": {
      "query": "Enter search terms here",
      "fields": [
        "List the field you want to search over",
        "List the field you want to search over",
        "List the field you want to search over"
      ]
    }
  }
}

  The following multi_match query asks Elasticsearch to query documents that contain the search terms "Michelle" or "Obama" 
in the fields headline, or short_description, or authors.

Example:-
```````
GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "Michelle Obama",
      "fields": [
        "headline",
        "short_description",
        "authors"
        ]
    }
  }
}

Expected response from Elasticsearch:-
````````````````````````````````````
  We see 3044 hits that contain "Michelle Obama" in the headline or short_description or author field. While the multi_match 
query increased the recall, it decreased the precision of the hits.

 For example, in our search for "Michelle Obama" related headlines, the top hit is a news headline featuring Bernie Sanders as
the main topic. In this headline, Michelle Obama is mentioned once in the field short_description.

 The following example boosts the score of documents that contain the search terms in the field headline. If the term "Michelle" 
or "Obama" are found in the field headline of a document, that document is given a higher score and is ranked higher in the 
search results.

 Per-field boosting:-
 ``````````````````
 Headlines mentioning "Michelle Obama" in the field headline are more likely to be related to our search than the headlines 
that mention "Michelle Obama" once or twice in the field short_description.

 To improve the precision of your search, you can designate one field to carry more weight than the others.

 This can be done by boosting the score of the field headline(per-field boosting). This is notated by adding a carat(^) 
symbol and number 2 to the desired field as shown below.

Syntax:-
``````

GET Enter_the_name_of_the_index_here/_search
{
  "query": {
    "multi_match": {
      "query": "Enter search terms",
      "fields": [
        "List field you want to boost^2",
        "List field you want to search over",
        "List field you want to search over"
      ]
    }
  }
}

  The following example boosts the score of documents that contain the search terms in the field headline. If the term 
"Michelle" or "Obama" are found in the field headline of a document, that document is given a higher score and is 
ranked higher in the search results.

GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "Michelle Obama",
      "fields": [
        "headline^2",
        "short_description",
        "authors"
        ]
    }
  }
}

 The documents containing the search terms "Michelle Obama" in the field headline are more likely to be about Michelle Obama. 
By using the per-field boosting, we have improved the precision of our search!

What happens when you use the multi_match query to search for a phrase?
``````````````````````````````````````````````````````````````````````
  While searching for Michelle Obama, the user remembers that she is throwing a party for all of her friends this weekend. 
She searches for news headlines regarding "party planning" to get some ideas for it.
 She uses the multi_match query to search for the phrase party planning.
 
Example:-
```````


GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "party ",
      "fields": [
        "headline^2",
        "short_description"
        
        ]
    }
  }
}


  1.But why does one of our top 10 hits feature Bernie Sanders planning a national tour for grassroots party activism?
  2.The terms "party" and "planning" are popular terms found in many documents.
  3.With the multi_match query, a document is considered as a hit if any one of these search terms were found in any one 
of the specified fields. It does not take into account the order or the proximity in which these search terms are found.
  4.Because of that, you will see loosely related search results included among the top hits.
  
Improving precision with phrase type match:-
``````````````````````````````````````````
 You can improve the precision of a multi_match query by adding the "type":"phrase" to the query.

 The phrase type performs a match_phrase query on each field and calculates a score for each field. Then, it assigns the
highest score among the fields to the document.

Syntax:-
``````	

GET Enter_the_name_of_the_index_here/_search
{
  "query": {
    "multi_match": {
      "query": "Enter search phrase",
      "fields": [
        "List field you want to boost^2",
        "List field you want to search over",
        "List field you want to search over"
      ],
      "type": "phrase"
    }
  }
}

Example:-
```````

GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "party ",
      "fields": [
        "headline^2",
        "short_description"
        
        ],
        "type": "phrase"
    }
  }
}

Combined Queries:-
````````````````
 1.There will be times when a user asks a multi-faceted question that requires multiple queries to answer.
 2.For example, a user may want to find political headlines about Michelle Obama published before the year 2016.
   This search is actually a combination of three queries:
    Query headlines that contain the search terms "Michelle Obama" in the field headline.
    Query "Michelle Obama" headlines from the "POLITICS" category.
    Query "Michelle Obama" headlines published before the year 2016
    One of the ways you can combine these queries is through a bool query.
	
Bool query:-
``````````	
 A query that matches documents matching boolean combinations of other queries. The bool query maps to Lucene BooleanQuery. 
It is built using one or more boolean clauses, each clause with a typed occurrence. The occurrence types are:

 Occur	  Description
 must     The clause (query) must appear in matching documents and will contribute to the score.

 filter   The clause (query) must appear in matching documents. However unlike must the score of the 
          query will be ignored. Filter clauses are executed in filter context, meaning that scoring is 
		  ignored and clauses are considered for caching.

 should   The clause (query) should appear in the matching document. If the bool query is in a query context 
          and has a must or filter clause then a document will match the bool query even if none of the should 
		  queries match. In this case these clauses are only used to influence the score. If the bool query is
		  in a filter context or has neither must or filter then at least one of the should queries must match
		  a document for it to match the bool query. This behavior may be explicitly controlled by setting the 
		  minimum_should_match parameter.

must_not  The clause (query) must not appear in the matching documents. Clauses are executed in filter context 
          meaning that scoring is ignored and clauses are considered for caching. Because scoring is ignored, a 
		  score of 0 for all documents is returned.
		  
		  
Syntax:-
```````

GET name_of_index/_search
{
  "query": {
    "bool": {
      "must": [
        {One or more queries can be specified here. A document MUST match all of these queries to be considered as a hit.}
      ],
      "must_not": [
        {A document must NOT match any of the queries specified here. It it does, it is excluded from the search results.}
      ],
      "should": [
        {A document does not have to match any queries specified here. However, it if it does match, this document is given a higher score.}
      ],
      "filter": [
        {These filters(queries) place documents in either yes or no category. Ones that fall into the yes category are included in the hits. }
      ]
    }
  }
}

A combination of query and aggregation request:-
```````````````````````````````````````````````
 A bool query can help you answer multi-faceted questions. Before we go over the four clauses of the bool query, we need to first 
understand what type of questions we can ask about Michelle Obama.
 Let's first figure out what headlines have been written about her.
 One way to understand that is by searching for categories of headlines that mention Michelle Obama.

Syntax:-
``````
GET Enter_name_of_the_index_here/_search
{
  "query": {
    "Enter match or match_phrase here": { 
	        "Enter the name of the field": "Enter the value you are looking for" 
	}
  },
  "aggregations": {
    "Name your aggregation here": {
      "Specify aggregation type here": {
        "field": "Name the field you want to aggregate here",
        "size": State how many buckets you want returned here
      }
    }
  }
}

Example:-
```````

GET news_head_line2/_search
{
  "query": {
    "match_phrase": {
      "headline": "Michelle Obama"
    }
  },
  "aggregations": {
    "category_mentions": {
      "terms": {
        "field": "category",
        "size": 100
      }
    }
  }
}


 Now let's get back to the bool query!
 With the bool query, you can combine multiple queries into one request and further specify boolean clauses to narrow down your search results.
 There are four clauses to choose from:
 must
 must_not
 should
 filter
 
The must clause:-
````````````````
 The must clause defines all queries(criteria) a document MUST match to be returned as hits. These criteria are expressed 
in the form of one or multiple queries.
 All queries in the must clause must be satisfied for a document to be returned as a hit. As a result, having more queries 
in the must clause will increase the precision of your query.

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "query": {
    "bool": {
      "must": [
        {
        "Enter match or match_phrase here": {
          "Enter the name of the field": "Enter the value you are looking for" 
         }
        },
        {
          "Enter match or match_phrase here": {
            "Enter the name of the field": "Enter the value you are looking for" 
          }
        }
      ]
    }
  }
}

Note:-
````
 The following is a bool query that uses the must clause. This query specifies that all hits must match the phrase 
"Michelle Obama" in the field headline and match the term "POLITICS" in the field category.


GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match_phrase": {
            "headline": "Michelle Obama"
          }
        },
        {
          "match": {
            "category": "ENTERTAINMENT"
          }
        }
      ]
    }
  }
}

The must_not clause:-
```````````````````
 The must_not clause defines queries(criteria) a document MUST NOT match to be included in the search results.

Syntax:-
```````
 GET Enter_name_of_the_index_here/_search
{
  "query": {
    "bool": {
      "must": [
        {
        "Enter match or match_phrase here": {
          "Enter the name of the field": "Enter the value you are looking for" 
         }
        },
       "must_not":[
         {
          "Enter match or match_phrase here": {
            "Enter the name of the field": "Enter the value you are looking for"
          }
        }
      ]
    }
  }
}

 What if you want all Michelle Obama headlines except for the ones that belong in the "WEDDINGS" category?
 The following bool query specifies that all hits must contain the phrase "Michelle Obama" in the field headline. 
However, the hits must_not contain the term "WEDDINGS" in the field category.

Example:-
``````
GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": 
        {
          "match_phrase": {
            "headline": "Michelle Obama"
          }
        },
        "must_not": [
          {
            "match": {
              "category": "WEDDINGS"
            }
          }
        ]
      
    }
  }
}

Expected response from Elasticsearch:-
````````````````````````````````````
 This query increases the recall(203 hits). It pulls up all the hits that contain the phrase "Michelle Obama" in the field 
headline. Among the hits, Elasticsearch excludes all documents that contain the term "WEDDINGS" in the field category.

The should clause:-
`````````````````
 The should clause adds "nice to have" queries(criteria). The documents do not need to match the "nice to have" queries 
to be considered as hits. However, the ones that do will be given a higher score so it shows up higher in the search results.

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "query": {
    "bool": {
      "must": [
        {
        "Enter match or match_phrase here: {
          "Enter the name of the field": "Enter the value you are looking for" 
         }
        },
       "should":[
         {
          "Enter match or match_phrase here": {
            "Enter the name of the field": "Enter the value you are looking for"
          }
        }
      ]
    }
  }
 
 1.Let's talk about a scenario where we may use the should clause. During the Black History Month, it is possible that the 
user may be looking up "Michelle Obama" in the context of "BLACK VOICES" category rather than in the context of "WEDDINGS", 
"TASTE", or "STYLE" categories.

 2.To accommodate this scenario, you may write a query where all hits MUST contain "Michelle Obama" in the field headline. 
Having the phrase "BLACK VOICES" in the category is not required. However, if a document contains the phrase "BLACK VOICES" 
in the field category, this document should be given a higher score and should be placed higher in the search results.

 3. To accommodate this scenario, you would write the following bool query. It specifies that all hits must match the phrase 
"Michelle Obama" in the field headline. Should a hit match the phrase "BLACK VOICES" in the field category, this hit will be 
given a higher score and will be shown higher in the search results.

Example:-
```````
GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match_phrase": {
            "headline": "Michelle Obama"
          }
        }
      ],
      "should": [
        {
          "match_phrase": {
            "category": "FOOD & DRINK"
          }
        }
      ]
    }
  }
}

The filter clause:-
`````````````````
 1.The filter clause contains filter queries that place documents into either "yes" or "no" category.
 2.For example, let's say you are looking for headlines published within a certain time range. Some documents will fall within this 
range(yes) or do not fall within this range(no).
 3.The filter clause only includes documents that fall into the yes category.

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "query": {
    "bool": {
      "must": [
        {
        "Enter match or match_phrase here": {
          "Enter the name of the field": "Enter the value you are looking for" 
         }
        }
        ],
       "filter":{
          "range":{
             "date": {
               "gte": "Enter lowest value of the range here",
               "lte": "Enter highest value of the range here"
          }
        }
      }
    }
  }
}
 
 Let's say we wanted to retrieve hits that must include the phrase "Michelle Obama" in the field headline. Among these hits, 
you want to include documents published within the date range "2014-03-25" and "2016-03-25".
 You bool query will look something like this.

Example:-
```````

GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": [
        {
        "match_phrase": {
          "headline": "Michelle Obama"
          }
         }
        ],
       "filter":{
          "range":{
             "date": {
               "gte": "2022-09-20",
               "lte": "2022-09-24"
          }
        }
      }
    }
  }
}


//////////////////////////////////////////////////////////////////////


//part-2
GET news_head_line2/_search



GET news_head_line_1/_search
{
  "track_total_hits": true
}

GET news_head_line2/_search
{
  "query": {
   "range": {
     "date": {
       "gte": "2022-09-20",
       "lte": "2022-09-21"
     }
   } 
  }
}



GET news_head_line2/_search
{
  "aggs": {
    "by_category": {
      "terms": {
        "field": "category",
        "size": 100
      }
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "match": {
      "category": "ENTERTAINMENT"
    }
  },
  "aggregations":{
        "popular_in_entertainment":{
          "significant_text": {
            "field": "headline"
          }
        }    
  }
}

GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Khloe Kardashian Kendall Jenner"
      }
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Kardashian Kim",
        "operator": "and"
      }
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Kardashian Kim",
        "minimum_should_match": 2
      }
    }
  }
}

DELETE news_head_line2
GET news_head_line


GET news_head_line2/_search
{
  "query": {
    "match": {
      "headline": {
        "query": "Shape of you"
      }
    }
  } 
}

GET news_head_line2/_search
{
  "query": {
    "match_phrase": {
      "headline": {
        "query": "You Need"
      }
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "Michelle Obama",
      "fields": [
        "headline^2",
        "short_description",
        "authors"
        ]
    }
  }
}


GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "party planning",
      "fields": [
        "headline^2",
        "short_description"
        
        ]
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "multi_match": {
      "query": "party ",
      "fields": [
        "headline^2",
        "short_description"
        
        ],
        "type": "phrase"
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "match_phrase": {
      "headline": "Michelle Obama"
    }
  },
  "aggregations": {
    "category_mentions": {
      "terms": {
        "field": "category",
        "size": 100
      }
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match_phrase": {
            "headline": "Michelle Obama"
          }
        },
        {
          "match": {
            "category": "ENTERTAINMENT"
          }
        }
      ]
    }
  }
}


GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": 
        {
          "match_phrase": {
            "headline": "Michelle Obama"
          }
        },
        "must_not": [
          {
            "match": {
              "category": "WEDDINGS"
            }
          }
        ]
      
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match_phrase": {
            "headline": "Michelle Obama"
          }
        }
      ],
      "should": [
        {
          "match_phrase": {
            "category": "FOOD & DRINK"
          }
        }
      ]
    }
  }
}

GET news_head_line2/_search
{
  "query": {
    "bool": {
      "must": [
        {
        "match_phrase": {
          "headline": "Michelle Obama"
          }
         }
        ],
       "filter":{
          "range":{
             "date": {
               "gte": "2022-09-20",
               "lte": "2022-09-24"
          }
        }
      }
    }
  }
}

GET news_head_line2/_search

////////////////////////////////////////////////////////////////////////////////


                                         Part 4: Running Aggregations with Elasticsearch and Kibana
										 ``````````````````````````````````````````````````````````
										 

There are two main ways to search in Elasticsearch:-
``````````````````````````````````````````````````	 

Queries:-
```````
 retrieve documents that match the specified criteria.
 
Aggregations:-
````````````
 present the summary of your data as metrics, statistics, and other analytics.
 
Get information about documents in an index:-
````````````````````````````````````````````
 The following query will retrieve information about documents in the ecommerce_data index. This query is a great way 
to explore the structure and content of your document.

Syntax:-
``````
GET Enter_name_of_the_index_here/_search

Example:-
```````
GET e_commerce_data/_search

Aggregations Request:-
```````````````````
Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "aggs": {
    "Name your aggregations here": {
      "Specify the aggregation type here": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Metric Aggregations:-
```````````````````
 Metricaggregations are used to compute numeric values based on your dataset. It can be used to calculate the values 
of sum,min, max, avg, unique count(cardinality) and etc.

Compute the sum of all unit prices in the index

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "aggs": {
    "Name your aggregations here": {
      "sum": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Example:-
``````
GET ecommerce_data/_search
{
  "aggs": {
    "sum_unit_price": {
      "sum": {
        "field": "UnitPrice"
      }
    }
  }
}
			
 If the purpose of running an aggregation is solely to get the aggregations results, you can add a size parameter 
and set it to 0 as shown below. This parameter prevents Elasticsearch from fetching the top 10 hits so that the 
aggregations results are shown at the top of the response.

Using a size parameter

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0, 
  "aggs": {
    "sum_unit_price": {
      "sum": {
        "field": "UnitPrice"
      }
    }
  }
}			

Compute the lowest(min) unit price of an item:-
````````````````````````````````````````````
Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "min": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Example:-
```````

GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "lowest_unit_price": {
      "min": {
        "field": "UnitPrice"
      }
    }
  }
}

Compute the highest(max) unit price of an item:-
``````````````````````````````````````````````
Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "max": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "highest_unit_price": {
      "max": {
        "field": "UnitPrice"
      }
    }
  }
}

Compute the average unit price of items:-
````````````````````````````````````````

Syntax:-
```````

GET Enter_name_of_the_index_here/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "avg": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "average_unit_price": {
      "avg": {
        "field": "UnitPrice"
      }
    }
  }
}

Stats Aggregation:-
````````````````` 
Compute the count, min, max, avg, sum in one go

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "stats": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Example:-
```````

GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "all_stats_unit_price": {
      "stats": {
        "field": "UnitPrice"
      }
    }
  }
}

"aggregations": {
    "all_stats_unit_price": {
      "count": 541909,     ---> which is total number of UnitPrice
      "min": -11062.06,
      "max": 38970,
      "avg": 4.611113626088513,
      "sum": 2498803.974
    }
  }
  
Cardinality Aggregation:-
````````````````````````
The cardinality aggregation computes the count of unique values for a given field.

Syntax:-
``````

GET Enter_name_of_the_index_here
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "cardinality": {
        "field": "Name the field you want to aggregate on here"
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "number_of_unique_customers": {
      "cardinality": {
        "field": "CustomerID"
      }
    }
  }
}

Limiting the scope of an aggregation:-
````````````````````````````````````
 In the previous examples, aggregations were performed on all documents in the ecommerce_data index. What if you want to run 
an aggregation on a subset of the documents?

 For example, our index contains e-commerce data from multiple countries. Let's say you want to calculate the average unit price 
of items sold in Germany.

 To limit the scope of the aggregation, you can add a query clause to the aggregations request. The query clause defines the subset 
of documents that aggregations should be performed on.

 The combined query and aggregations look like the following.

Syntax:-
```````

GET Enter_name_of_the_index_here/_search
{
  "size": 0,
  "query": {
    "Enter match or match_phrase here": {
      "Enter the name of the field": "Enter the value you are looking for"
    }
  },
  "aggregations": {
    "Name your aggregations here": {
      "Specify aggregations type here": {
        "field": "Name the field you want to aggregate here"
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0, 
  "query": {
    "match": {
      "Country": "Germany"
    }
  },
  "aggs": {
    "germany_average_unit_price": {
      "avg": {
        "field": "UnitPrice"
      }
    }
  }
}

 The combination of query and aggregations request allowed us to perform aggregations on a subset of documents. What 
if we wanted to perform aggregations on several subsets of documents?

This is where Bucket Aggregations come into play!

Bucket Aggregations:-
````````````````````
 When you want to aggregate on several subsets of documents, bucket aggregations will come in handy. Bucket aggregations 
group documents into several sets of documents called buckets. All documents in a bucket share a common criteria.

 The following are different types of bucket aggregations.

 1.Date Histogram Aggregation
 2.Histogram Aggregation
 3.Range Aggregation
 4.Terms aggregation
 
1. Date Histogram Aggregation:-
``````````````````````````````
 1.When you are looking to group data by time interval, the date_histogram aggregation will prove very useful!
 2.Our ecommerce_data index contains transaction data that has been collected over time(from the year 2010 to 2011).
 3.If we are looking to get insights about transactions over time, our first instinct should be to run the date_histogram aggregation.
 
 4.There are two ways to define a time interval with date_histogram aggregation. These are Fixed_interval and Calendar_interval.
 
 Fixed_interval With the fixed_interval, the interval is always constant.

Example:-
```````
 Create a bucket for every 8 hour interval.

Syntax:-
``````

GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "date_histogram": {
        "field":"Name the field you want to aggregate on here",
        "fixed_interval": "Specify the interval here"
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transactions_by_8_hrs": {
      "date_histogram": {
        "field": "InvoiceDate",
        "fixed_interva": "8h"
      }
    }
  }
}

 Another way we can define the time interval is through the calendar_interval.

 Calendar_interval With the calendar_interval, the interval may vary.

 For example, we could choose a time interval of day, month or year. But daylight savings can change the length of specific days, months can have different number of days, and leap seconds can be tacked onto a particular year.

 So the time interval of day, month, or leap seconds could vary!

 A scenario where you might use the calendar_interval is when you want to calculate the monthly revenue.

Ex:-
Split data into monthly buckets.

Syntax:-
``````

GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "date_histogram": {
        "field":"Name the field you want to aggregate on here",
        "calendar_interval": "Specify the interval here"
      }
    }
  }
}
Example:-
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transaction_for_month": {
      "date_histogram": {
        "field": "InvoiceDate",
        "calendar_interval": "1M"
      }
    }
  }
}

Bucket sorting for date histogram aggregation:-
``````````````````````````````````````````````

By default, the date_histogram aggregation sorts buckets based on the "key" values in ascending order.

To reverse this order, you can add an order parameter to the aggregations as shown below. Then, specify that you want to sort buckets based on the "_key" values in descending(desc) order.

Example:

GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transactions_by_month": {
      "date_histogram": {
        "field": "InvoiceDate",
        "calendar_interval": "1M",
        "order": {
          "_key": "desc"
        }
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transaction_for_month": {
      "date_histogram": {
        "field": "InvoiceDate",
        "calendar_interval": "1M",
        "order": {
          "_key": "desc"
        }
      }
    }
  }
}

Histogram Aggregation:-
`````````````````````
 1.With the date_histogram aggregation, we were able to create buckets based on time intervals.
 2.The histogram aggregation creates buckets based on any numerical interval.
   Ex:-
    Create a buckets based on price interval that increases in increments of 10.

Syntax:-
```````

GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "Name your aggregations here": {
      "histogram": {
        "field":"Name the field you want to aggregate on here",
        "interval": Specify the interval here
      }
    }
  }
}

Example:-
``````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transactions_per_price_interval": {
      "histogram": {
        "field": "UnitPrice",
        "interval": 10
      }
    }
  }
}

Bucket sorting for histogram aggregation;-
`````````````````````````````````````````
 By default, the histogram aggregation sorts buckets based on the _key values in ascending order. To reverse this 
order, you can add an order parameter to the aggregation. Then, specify that you want to sort buckets based on the 
_key values in descending(desc) order!

Example:-
````````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transactions_per_price_interval": {
      "histogram": {
        "field": "UnitPrice",
        "interval": 10,
        "order": {
          "_key": "desc"
        }
      }
    }
  }
}

Range Aggregation:-
``````````````````
 The range aggregation is similar to the histogram aggregation in that it can create buckets based on any numerical 
interval. The difference is that the range aggregation allows you to define intervals of varying sizes so you can 
customize it to your use case.

 For example, what if you wanted to know the number of transactions for items from varying price ranges(between 0 and 
$50, between $50-$200, and between $200 and up)?

Syntax:-
``````
GET Enter_name_of_the_index_here/_search
{
  "size": 0,
  "aggs": {
   "Name your aggregations here": {
      "range": {
        "field": "Name the field you want to aggregate on here",
        "ranges": [
          {
            "to": x
          },
          {
            "from": x,
            "to": y
          },
          {
            "from": z
          }
        ]
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transaction_per_custome_price_ranges": {
      "range": {
        "field": "UnitPrice",
        "ranges": [
          {
            "to": 50
          },
          {
            "from": 50,
            "to": 200
          },
          {
            "from": 200
          }
        ]
      }
    }
  }
}

Bucket sorting for range aggregation:-
````````````````````````````````````
 The range aggregation is sorted based on the input ranges you specify and it cannot be sorted any other way!

Terms Aggregation:-
`````````````````
 The terms aggregation creates a new bucket for every unique term it encounters for the specified field. It is
often used to find the most frequently found terms in a document.
 For example, let's say you want to identify 5 customers with the highest number of transactions(documents).

Syntax:-
``````

GET Enter_name_of_the_index_here/_search
{
  "aggs": {
    "Name your aggregations here": {
      "terms": {
        "field": "Name the field you want to aggregate on here",
        "size": State how many top results you want returned here
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0, 
  "aggs": {
    "top_5_cutomer": {
      "terms": {
        "field": "CustomerID",
        "size": 5
      }
    }
  }
}

Bucket sorting for terms aggregation:-
````````````````````````````````````
 By default, the terms aggregation sorts buckets based on the "doc_count" values in descending order. To reverse this 
order, you can add an order parameter to the aggregation. Then, specify that you want to sort buckets based on 
the _count values in ascending(asc) order!

Example:-
````````
GET ecommerce_data/_search
{
  "size": 0, 
  "aggs": {
    "top_5_cutomer": {
      "terms": {
        "field": "CustomerID",
        "size": 5,
        "order": {
          "_key": "asc"
        }
      }
    }
  }
}

Combined Aggregations:-
`````````````````````
 1.So far, we have ran metric aggregations or bucket aggregations to answer simple questions.
 2.There will be times when we will ask more complex questions that require running combinations of these aggregations.
 3.For example, let's say we wanted to know the sum of revenue per day.
 4.To get the answer, we need to first split our data into daily buckets(date_histogram aggregation).
  Within each bucket, we need to perform metric aggregations to calculate the daily revenue.

Calculate the daily revenue:-
```````````````````````````
The combined aggregations request looks like the following:

Syntax:-
``````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transactions_per_day": {
      "date_histogram": {
        "field": "InvoiceDate",
        "calendar_interval": "day"
      },
      "aggs": {
        "daily_revenue": {
          "sum": {
            "script": {
              "source": "doc['UnitPrice'].value * doc['Quantity'].value"
            }
          }
        }
      }
    }
  }
}

Example:-
```````
GET ecommerce_data/_search
{
  "size": 0,
  "aggs": {
    "transaction_per_day": {
      "date_histogram": {
        "field": "InvoiceDate",
        "calendar_interval": "day"
      },
     "aggs": {
       "daily_revenue": {
         "sum": {
           "script": {
             "source": "doc['UnitPrice'].value*doc['Quantity'].value"
           }
         }
       }
     }
    }
  }
}
